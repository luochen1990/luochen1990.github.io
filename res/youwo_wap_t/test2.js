// Generated by CoffeeScript 1.6.3
(function() {
  var animate, array_b_search, assert, b_search, best, canvas, cartesian_product, err, height, i, id, img, log, pen, polyline, position, random_gen, ranged_random_gen, square, sum, switch_anim, testpolyline, vec, weight, width, _ref,
    __slice = [].slice;

  sum = function(n) {
    var r, x, _i, _len;
    r = 0;
    for (_i = 0, _len = n.length; _i < _len; _i++) {
      x = n[_i];
      r += x;
    }
    return r;
  };

  square = function(n) {
    return n * n;
  };

  best = function(ls, better) {
    var it, rext, _i, _len;
    rext = null;
    for (_i = 0, _len = ls.length; _i < _len; _i++) {
      it = ls[_i];
      rext = (rext == null) || better(it, rext) ? it : rext;
    }
    return rext;
  };

  cartesian_product = function(la, lb) {
    var r, x, y, _i, _j, _len, _len1;
    r = [];
    for (_i = 0, _len = la.length; _i < _len; _i++) {
      x = la[_i];
      for (_j = 0, _len1 = lb.length; _j < _len1; _j++) {
        y = lb[_j];
        r.push([x, y]);
      }
    }
    return r;
  };

  random_gen = function(seed) {
    return function() {
      var x;
      x = Math.sin(seed++) * 10000;
      return x - Math.floor(x);
    };
  };

  ranged_random_gen = function(range, seed) {
    var random;
    random = random_gen(seed);
    return function() {
      return Math.floor(random() * range);
    };
  };

  weight = function(arr) {
    var tot;
    tot = sum(arr);
    return function(x) {
      return x / tot;
    };
  };

  position = function(xs, xt, x) {
    return (x - xs) / (xt - xs);
  };

  log = function(it) {
    return console.log(JSON.stringify(it));
  };

  err = function(it) {
    return alert(JSON.stringify(it));
  };

  assert = function(flag) {
    if (!flag) {
      return alert("assertion error") && (1 / 0);
    }
  };

  vec = {
    zero: [0, 0],
    onex: [1, 0],
    oney: [0, 1],
    add: function(va, vb) {
      return [va[0] + vb[0], va[1] + vb[1]];
    },
    opp: function(v) {
      return [-v[0], -v[1]];
    },
    sub: function(va, vb) {
      return [va[0] - vb[0], va[1] - vb[1]];
    },
    sum: function(vs) {
      var v;
      return [
        sum((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = vs.length; _i < _len; _i++) {
            v = vs[_i];
            _results.push(v[0]);
          }
          return _results;
        })()), sum((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = vs.length; _i < _len; _i++) {
            v = vs[_i];
            _results.push(v[1]);
          }
          return _results;
        })())
      ];
    },
    mul: function(va, k) {
      return [va[0] * k, va[1] * k];
    },
    mul2: function(va, vb) {
      return [va[0] * vb[0], va[1] * vb[1]];
    },
    len: function(v) {
      return Math.sqrt(square(v[0]) + square(v[1]));
    },
    norm: function(v) {
      var len;
      len = Math.sqrt(square(v[0]) + square(v[1]));
      if (len > 1e-8) {
        return [v[0] / len, v[1] / len];
      } else {
        return [0, 0];
      }
    },
    rot: function(v) {
      return [-v[1], v[0]];
    }
  };

  vec.mix = function(va, vb, k) {
    return vec.add(va, vec.mul(vec.sub(vb, va), k));
  };

  b_search = function(f, xs, xt, midx, y_lefter, x_close_enough) {
    var iter;
    iter = function(xl, xu, yl, yu, y) {
      var xm, ym;
      if (x_close_enough(xl, xu)) {
        return [xl, xu];
      } else {
        xm = midx(xl, xu);
        ym = f(xm);
        if (y_lefter(y, ym)) {
          return iter(xl, xm, yl, ym, y);
        } else {
          return iter(xm, xu, ym, yu, y);
        }
      }
    };
    return function(y) {
      return iter(xs, xt, f(xs), f(xt), y);
    };
  };

  array_b_search = function(arr, reversed) {
    var f, midx, x_close_enough, y_lefter;
    if (reversed == null) {
      reversed = false;
    }
    if (reversed) {
      f = function(x) {
        if (x === -1) {
          return Infinity;
        } else if (x === arr.length) {
          return -Infinity;
        } else {
          return arr[x];
        }
      };
      y_lefter = function(y0, y1) {
        return y0 > y1;
      };
    } else {
      f = function(x) {
        if (x === -1) {
          return -Infinity;
        } else if (x === arr.length) {
          return Infinity;
        } else {
          return arr[x];
        }
      };
      y_lefter = function(y0, y1) {
        return y0 < y1;
      };
    }
    midx = function(x0, x1) {
      return Math.floor((x0 + x1) / 2);
    };
    x_close_enough = function(x0, x1) {
      return x1 - x0 <= 1;
    };
    return b_search(f, -1, arr.length, midx, y_lefter, x_close_enough);
  };

  polyline = function(mix) {
    return function() {
      var it, line, n, t_, t_i, t_v, v_;
      t_v = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      n = t_v.length;
      assert(n >= 2);
      t_ = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = t_v.length; _i < _len; _i++) {
          it = t_v[_i];
          _results.push(it[0]);
        }
        return _results;
      })();
      v_ = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = t_v.length; _i < _len; _i++) {
          it = t_v[_i];
          _results.push(it[1]);
        }
        return _results;
      })();
      t_i = array_b_search(t_);
      line = function(i, j) {
        return function(t) {
          return mix(v_[i], v_[j], position(t_[i], t_[j], t));
        };
      };
      return function(t) {
        var expand_line, i0, i1, _ref;
        _ref = t_i(t), i0 = _ref[0], i1 = _ref[1];
        expand_line = i0 < 0 ? line(0, 1) : i1 >= n ? line(n - 2, n - 1) : line(i0, i1);
        return expand_line(t);
      };
    };
  };

  vec.polyline = function() {
    var t_p;
    t_p = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return polyline(vec.mix).apply(null, t_p);
  };

  testpolyline = vec.polyline([0, [-1, -1]], [1, [2, 2]]);

  animate = function(draw, clear, status, duration, fps) {
    var frame_interval, frame_num;
    if (fps == null) {
      fps = 50;
    }
    frame_num = duration * fps;
    frame_interval = 1000 / fps;
    return function() {
      var anim;
      anim = function(frame_id) {
        clear();
        draw(status(frame_id / frame_num));
        if (frame_id < frame_num) {
          return setTimeout((function() {
            return anim(frame_id + 1);
          }), frame_interval);
        }
      };
      return anim(0);
    };
  };

  canvas = document.getElementById('canv');

  _ref = [canvas.width, canvas.height], width = _ref[0], height = _ref[1];

  pen = canvas.getContext("2d");

  img = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 1; _i <= 3; i = ++_i) {
      _results.push(document.getElementById("p" + i));
    }
    return _results;
  })();

  switch_anim = function(img0, img1) {
    var a, clear, draw, k, p0f, p1f, pos, s0f, s1f, status, sz, _ref1;
    draw = function(st) {
      if (!st.flipped) {
        pen.drawImage.apply(pen, [img1].concat(__slice.call(st.pos1), __slice.call(st.sz1)));
        return pen.drawImage.apply(pen, [img0].concat(__slice.call(st.pos0), __slice.call(st.sz0)));
      } else {
        pen.drawImage.apply(pen, [img0].concat(__slice.call(st.pos0), __slice.call(st.sz0)));
        return pen.drawImage.apply(pen, [img1].concat(__slice.call(st.pos1), __slice.call(st.sz1)));
      }
    };
    clear = function() {
      return pen.clearRect(0, 0, width, height);
    };
    pos = [[0, 80], [140, 40], [280, 0]];
    sz = [[240, 360], [280, 420], [320, 480]];
    _ref1 = (function() {
      var _i, _len, _ref1, _ref2, _results;
      _ref1 = cartesian_product([pos, sz], [2, 0]);
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        _ref2 = _ref1[_i], a = _ref2[0], k = _ref2[1];
        _results.push(vec.polyline([0, a[1]], [0.5, a[k]], [1, a[1]]));
      }
      return _results;
    })(), p0f = _ref1[0], p1f = _ref1[1], s0f = _ref1[2], s1f = _ref1[3];
    status = function(k) {
      return {
        flipped: k > 0.5,
        pos0: p0f(k),
        pos1: p1f(k),
        sz0: s0f(k),
        sz1: s1f(k)
      };
    };
    return animate(draw, clear, status, 1)();
  };

  pen.drawImage.apply(pen, [img[0]].concat(__slice.call([140, 40]), __slice.call([280, 420])));

  id = 0;

  $('#next').click(function() {
    var id2;
    id2 = (id + 1) % img.length;
    switch_anim(img[id], img[id2]);
    return id = id2;
  });

  $('#prev').click(function() {
    var id2;
    id2 = (id + img.length - 1) % img.length;
    switch_anim(img[id], img[id2]);
    return id = id2;
  });

}).call(this);
